using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace EndpointHelpers;

[Generator]
public sealed class RedirectToActionGenerator : IIncrementalGenerator
{
    private const string Namespace = "EndpointHelpers";
    private const string GenerateAttributeName = "GenerateRedirectToActionAttribute";
    private const string IgnoreAttributeName = "RedirectToActionIgnoreAttribute";
    private const string UnifiedGenerateAttributeName = "GenerateEndpointHelpersAttribute";
    private const string NonActionAttributeName = "Microsoft.AspNetCore.Mvc.NonActionAttribute";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var generateTargets = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                $"{Namespace}.{GenerateAttributeName}",
                static (node, _) => node is ClassDeclarationSyntax or MethodDeclarationSyntax,
                static (ctx, _) => GetControllerMetadataName(ctx.TargetSymbol))
            .Where(static t => t is not null);

        var unifiedTargets = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                $"{Namespace}.{UnifiedGenerateAttributeName}",
                static (node, _) => node is ClassDeclarationSyntax or MethodDeclarationSyntax,
                static (ctx, _) => GetControllerMetadataName(ctx.TargetSymbol))
            .Where(static t => t is not null);

        var targets = generateTargets
            .Collect()
            .Combine(unifiedTargets.Collect())
            .Select(static (x, _) => x.Left.AddRange(x.Right));

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(targets),
            static (ctx, t) => Generate(ctx, t.Left, t.Right!));
    }

    private static string? GetControllerMetadataName(ISymbol symbol)
    {
        return symbol switch
        {
            INamedTypeSymbol type => GetMetadataName(type),
            IMethodSymbol method => method.ContainingType is null ? null : GetMetadataName(method.ContainingType),
            _ => null
        };
    }

    private static void Generate(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<string?> members)
    {
        var assemblyHasGenerate = compilation.Assembly.GetAttributes()
            .Any(a => a.AttributeClass?.ToDisplayString() ==
                      $"{Namespace}.{GenerateAttributeName}" ||
                      a.AttributeClass?.ToDisplayString() ==
                      $"{Namespace}.{UnifiedGenerateAttributeName}");

        INamedTypeSymbol[] controllers;

        if (assemblyHasGenerate)
        {
            controllers = GetAllTypes(compilation.GlobalNamespace)
                .Where(t =>
                    t.TypeKind == TypeKind.Class &&
                    !t.IsAbstract &&
                    t.Name.EndsWith("Controller"))
                .ToArray();
        }
        else
        {
            if (members.IsDefaultOrEmpty)
                return;

            controllers = members
                .Distinct()
                .Select(name => compilation.GetTypeByMetadataName(name!))
                .Where(s => s is not null)
                .Distinct(SymbolEqualityComparer.Default)
                .Cast<INamedTypeSymbol>()
                .ToArray();
        }

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.AspNetCore.Mvc;");
        sb.AppendLine("using Microsoft.AspNetCore.Routing;");
        sb.AppendLine();
        sb.AppendLine($"namespace {Namespace};");
        sb.AppendLine();

        sb.AppendLine("public static class ControllerExtensions");
        sb.AppendLine("{");

        foreach (var controller in controllers)
        {
            var generateAttr = controller.GetAttributes()
                .FirstOrDefault(a =>
                    a.AttributeClass?.ToDisplayString() ==
                    $"{Namespace}.{GenerateAttributeName}" ||
                    a.AttributeClass?.ToDisplayString() ==
                    $"{Namespace}.{UnifiedGenerateAttributeName}");

            var methods = controller.GetMembers()
                .OfType<IMethodSymbol>()
                .Where(m =>
                    m.MethodKind == MethodKind.Ordinary &&
                    m.DeclaredAccessibility == Accessibility.Public &&
                    !m.GetAttributes().Any(a =>
                        a.AttributeClass?.ToDisplayString() ==
                        $"{Namespace}.{IgnoreAttributeName}") &&
                    !m.GetAttributes().Any(a =>
                        a.AttributeClass?.ToDisplayString() ==
                        NonActionAttributeName) &&
                    (assemblyHasGenerate ||
                     generateAttr != null ||
                     m.GetAttributes().Any(a =>
                         a.AttributeClass?.ToDisplayString() ==
                         $"{Namespace}.{GenerateAttributeName}" ||
                         a.AttributeClass?.ToDisplayString() ==
                         $"{Namespace}.{UnifiedGenerateAttributeName}")))
                .ToArray();

            if (methods.Length == 0)
                continue;

            sb.AppendLine($"    extension({controller.ToDisplayString()} controller)");
            sb.AppendLine("    {");

            var controllerName = controller.Name.Replace("Controller", "");

            foreach (var method in methods)
            {
                var action = method.Name;
                var actionMethodName = $"RedirectTo{action}";

                var parameters = string.Join(
                    ", ",
                    method.Parameters.Select(p =>
                        $"{p.Type.ToDisplayString()} {p.Name}"));

                sb.AppendLine($"        public RedirectToActionResult {actionMethodName}({parameters})");
                sb.AppendLine("        {");

                if (method.Parameters.Length == 0)
                {
                    sb.AppendLine($"            return controller.RedirectToAction(\"{action}\", \"{controllerName}\")!;");
                }
                else
                {
                    sb.AppendLine("            return controller.RedirectToAction(");
                    sb.AppendLine($"                \"{action}\",");
                    sb.AppendLine($"                \"{controllerName}\",");
                    sb.AppendLine("                new RouteValueDictionary");
                    sb.AppendLine("                {");

                    foreach (var p in method.Parameters)
                        sb.AppendLine($"                    {{ \"{p.Name}\", {p.Name} }},");

                    sb.AppendLine("                })!;");
                }

                sb.AppendLine("        }");
                sb.AppendLine();
            }

            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        context.AddSource(
            "RedirectToActionExtensions.g.cs",
            SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static IEnumerable<INamedTypeSymbol> GetAllTypes(INamespaceSymbol ns)
    {
        foreach (var type in ns.GetTypeMembers())
            yield return type;

        foreach (var nested in ns.GetNamespaceMembers())
        foreach (var type in GetAllTypes(nested))
            yield return type;
    }

    private static string GetMetadataName(INamedTypeSymbol type)
    {
        var name = type.MetadataName;
        var current = type.ContainingType;

        while (current is not null)
        {
            name = $"{current.MetadataName}+{name}";
            current = current.ContainingType;
        }

        var ns = type.ContainingNamespace?.ToDisplayString();
        return string.IsNullOrEmpty(ns) ? name : $"{ns}.{name}";
    }
}
