namespace EndpointHelpers;

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


[Generator]
public sealed class LinkGeneratorGenerator : IIncrementalGenerator
{
    private const string Namespace = "EndpointHelpers";
    private const string GenerateAttributeName = "GenerateLinkGeneratorAttribute";
    private const string IgnoreAttributeName = "LinkGeneratorIgnoreAttribute";
    private const string NonActionAttributeName = "Microsoft.AspNetCore.Mvc.NonActionAttribute";

    //lang=cs
    private const string AttributeSourceCode = $"""
                                                 // <auto-generated/>

                                                 namespace {Namespace};

                                                 [System.AttributeUsage(
                                                     System.AttributeTargets.Method |
                                                     System.AttributeTargets.Class |
                                                     System.AttributeTargets.Assembly)]
                                                 public sealed class {GenerateAttributeName} : System.Attribute;

                                                 [System.AttributeUsage(System.AttributeTargets.Method)]
                                                 public sealed class {IgnoreAttributeName} : System.Attribute;
                                                 """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource(
                "Attributes.g.cs",
                SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => s is ClassDeclarationSyntax or MethodDeclarationSyntax,
                static (ctx, _) => GetTarget(ctx))
            .Where(static t => t is not null);

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            static (ctx, t) => Generate(ctx, t.Left, t.Right!));
    }

    private static MemberDeclarationSyntax? GetTarget(GeneratorSyntaxContext context)
    {
        if (context.Node is ClassDeclarationSyntax cls)
        {
            foreach (var list in cls.AttributeLists)
            foreach (var attr in list.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attr).Symbol is IMethodSymbol symbol &&
                    symbol.ContainingType.ToDisplayString() ==
                    $"{Namespace}.{GenerateAttributeName}")
                    return cls;
            }
        }

        if (context.Node is MethodDeclarationSyntax method)
        {
            foreach (var list in method.AttributeLists)
            foreach (var attr in list.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attr).Symbol is IMethodSymbol symbol &&
                    symbol.ContainingType.ToDisplayString() ==
                    $"{Namespace}.{GenerateAttributeName}")
                    return method;
            }
        }

        return null;
    }

    private static void Generate(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<MemberDeclarationSyntax> members)
    {
        var assemblyHasGenerate = compilation.Assembly.GetAttributes()
            .Any(a => a.AttributeClass?.ToDisplayString() ==
                      $"{Namespace}.{GenerateAttributeName}");

        INamedTypeSymbol[] controllers;

        if (assemblyHasGenerate)
        {
            controllers = GetAllTypes(compilation.GlobalNamespace)
                .Where(t =>
                    t.TypeKind == TypeKind.Class &&
                    !t.IsAbstract &&
                    t.Name.EndsWith("Controller"))
                .ToArray();
        }
        else
        {
            if (members.IsDefaultOrEmpty)
                return;

            controllers = members
                .Select(m =>
                {
                    if (m is ClassDeclarationSyntax cls)
                        return compilation.GetSemanticModel(cls.SyntaxTree)
                            .GetDeclaredSymbol(cls) as INamedTypeSymbol;

                    if (m is MethodDeclarationSyntax method)
                        return (compilation.GetSemanticModel(method.SyntaxTree)
                            .GetDeclaredSymbol(method) as IMethodSymbol)?.ContainingType;

                    return null;
                })
                .Where(s => s is not null)
                .Distinct(SymbolEqualityComparer.Default)
                .Cast<INamedTypeSymbol>()
                .ToArray();
        }

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.AspNetCore.Http;");
        sb.AppendLine("using Microsoft.AspNetCore.Routing;");
        sb.AppendLine();
        sb.AppendLine($"namespace {Namespace};");
        sb.AppendLine();

        foreach (var controller in controllers)
        {
            var generateAttr = controller.GetAttributes()
                .FirstOrDefault(a =>
                    a.AttributeClass?.ToDisplayString() ==
                    $"{Namespace}.{GenerateAttributeName}");

            var controllerName = controller.Name.Replace("Controller", "");
            var helperClassName = $"{controller.Name}LinkGenerator";

            sb.AppendLine($"public sealed class {helperClassName}(LinkGenerator links)");
            sb.AppendLine("{");

            var methods = controller.GetMembers()
                .OfType<IMethodSymbol>()
                .Where(m =>
                    m.MethodKind == MethodKind.Ordinary &&
                    m.DeclaredAccessibility == Accessibility.Public &&
                    !m.GetAttributes().Any(a =>
                        a.AttributeClass?.ToDisplayString() ==
                        $"{Namespace}.{IgnoreAttributeName}") &&
                    !m.GetAttributes().Any(a =>
                        a.AttributeClass?.ToDisplayString() ==
                        NonActionAttributeName) &&
                    (assemblyHasGenerate ||
                     generateAttr != null ||
                     m.GetAttributes().Any(a =>
                         a.AttributeClass?.ToDisplayString() ==
                         $"{Namespace}.{GenerateAttributeName}")));

            foreach (var method in methods)
            {
                var action = method.Name;
                
                var actionMethodName = $"Get{action}Path";
                
                var parameters = string.Join(
                    ", ",
                    method.Parameters.Select(p =>
                        $"{p.Type.ToDisplayString()} {p.Name}" +
                        (p.IsOptional
                            ? $" = {(p.ExplicitDefaultValue == null
                                ? "null"
                                : p.Type.SpecialType == SpecialType.System_String
                                    ? $"\"{p.ExplicitDefaultValue}\""
                                    : p.ExplicitDefaultValue.ToString())}"
                            : string.Empty)));

                sb.AppendLine($"    public string {actionMethodName}({parameters})");
                sb.AppendLine("    {");
                sb.AppendLine("        return links.GetPathByAction(");
                sb.AppendLine($"            action: \"{action}\",");
                sb.AppendLine($"            controller: \"{controllerName}\",");
                sb.AppendLine(method.Parameters.Length == 0
                    ? "            values: null);"
                    : "            values: new");
                if (method.Parameters.Length > 0)
                {
                    sb.AppendLine("            {");
                    foreach (var p in method.Parameters)
                        sb.AppendLine($"                {p.Name},");
                    sb.AppendLine("            });");
                }
                sb.AppendLine("    }");
                sb.AppendLine();

                sb.AppendLine(
                    $"    public string {actionMethodName}(HttpContext httpContext{(method.Parameters.Length > 0 ? ", " : "")}{parameters})");
                sb.AppendLine("    {");
                sb.AppendLine("        return links.GetPathByAction(");
                sb.AppendLine("            httpContext,");
                sb.AppendLine($"            action: \"{action}\",");
                sb.AppendLine($"            controller: \"{controllerName}\",");
                sb.AppendLine(method.Parameters.Length == 0
                    ? "            values: null);"
                    : "            values: new");
                if (method.Parameters.Length > 0)
                {
                    sb.AppendLine("            {");
                    foreach (var p in method.Parameters)
                        sb.AppendLine($"                {p.Name},");
                    sb.AppendLine("            });");
                }
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }

        sb.AppendLine("public static class LinkGeneratorExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    extension(LinkGenerator links)");
        sb.AppendLine("    {");

        foreach (var controller in controllers)
        {
            var helperClassName = $"{controller.Name}LinkGenerator";
            var propertyName = controller.Name.Replace("Controller", "");

            sb.AppendLine($"        public {helperClassName} {propertyName}");
            sb.AppendLine("        {");
            sb.AppendLine("            get");
            sb.AppendLine("            {");
            sb.AppendLine($"                return new {helperClassName}(links);");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource(
            "LinkGeneratorExtensions.g.cs",
            SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static IEnumerable<INamedTypeSymbol> GetAllTypes(INamespaceSymbol ns)
    {
        foreach (var type in ns.GetTypeMembers())
            yield return type;

        foreach (var nested in ns.GetNamespaceMembers())
        foreach (var type in GetAllTypes(nested))
            yield return type;
    }
}

